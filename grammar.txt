Terminais:
'begin', 'end', '\$'
'if', 'else', 'while', 'return', 'int', 'void', 'float'
'+', '-', '*', '/', '=', '==', '!=', '<', '>', '<=', '>=', '||', '&&', '!'
';', ',', '(', ')', '{', '}', '[', ']'
'literals'
'identifiers'

Não-terminais:
'Program' → FunctList \$
'FunctList' → Func FunctList
'FunctList' → ε
'Func' → TypeSpec Identif ( ) { Stmts }
'Stmts' → Stmt ; Stmts
'Stmts' → ε
'Stmt' → SimpleStmt
'Stmt' → Conditional
'Stmt' → Loop
'SimpStmt' → VarDefine
'SimpStmt' → Expr
'Expr' → Math
'Expr' → Logic
'CondIf' → if ( Logic ) { Stmts } CondElse endif
'CondElse' → else { Stmts } 
'CondElse' → ε
'Loop' → while ( Logic ) { Stmts }
'VarDefine' → TypeSpec Identif
'Math' → Identif = MathExprAdd
'MathExprAdd' → MathExprAdd AddOp MathExprMult
'MathExprAdd' → MathExprMult
'MathExprMult' → MathExprMult MultOp MathExprMult
'MathExprMult' → Identif
'AddOp' → +
'AddOp' → -
'MultOp' → *
'MultOp' → /
'Logic' → LogicSeq LopComp LogicSeq
'LopNeg' → !
'LopConec' → ||
'LopConec' → &&
'LopComp' → ==
'LopComp' → >
'LopComp' → <
'LopComp' → >=
'LopComp' → <=
'LopComp' → !=






















]
Program         ::= { Function }

Function        ::= Type Identifier "(" [ ParameterList ] ")" "{" { Declaration } { Statement } "}"

ParameterList   ::= Type Identifier { "," Type Identifier }

Declaration     ::= Type Identifier { "," Identifier } ";"

Type            ::= "int" | "float" | "char"

Statement       ::= Block | Assignment | IfStatement | WhileStatement | ReturnStatement | ExpressionStatement

Block           ::= "{" { Statement } "}"

Assignment      ::= Identifier "=" Expression ";"

IfStatement     ::= "if" "(" Condition ")" Statement [ "else" Statement ]

WhileStatement  ::= "while" "(" Condition ")" Statement

ForStatement    ::= "for" "(" [ Expression ] ";" [ Condition ] ";" [ Expression ] ")" Statement

ReturnStatement ::= "return" [ Expression ] ";"

ExpressionStatement ::= Expression ";"

Expression      ::= Term { ( "+" | "-" ) Term }

Term            ::= Factor { ( "*" | "/" | "%" ) Factor }

Factor          ::= Identifier | Literal | "(" Expression ")" | FunctionCall

FunctionCall    ::= Identifier "(" [ ArgumentList ] ")"

ArgumentList    ::= Expression { "," Expression }

Condition       ::= Expression ( "==" | "!=" | "<" | ">" | "<=" | ">=" ) Expression

Identifier      ::= letter { letter | digit }
Literal         ::= integerLiteral | floatingLiteral | charLiteral | stringLiteral

integerLiteral  ::= digit { digit }
floatingLiteral ::= digit { digit } "." digit { digit }
charLiteral     ::= "'" character "'"
stringLiteral   ::= '"' { character } '"'
